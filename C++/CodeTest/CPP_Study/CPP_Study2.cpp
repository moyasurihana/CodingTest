//#include <iostream>
//using namespace std;
//
//// 불리언과 실수
//
//bool isHighLevel = true;
//bool isPlayer = true;
//bool isMale= false;
//
///* 사실 bool은 그냥 1바이트 정수에 불과
//왜 정수랑 차별을 두는것인가?
//어셈블리에서는 bool 이라는게 없어
//bool만 봐도 참 거짓이라는 힌트를 준다 (가독성)
//*/
//int isFemale = 1;
//
//// 여성의 개수? 라고 오인 할 수 있잖아.
//
//// bool이 왜 1바이트까지 필요로 하지? 
//// 어셈블리 보면, 최소단위가 1바이트를 사용하잖아
//
//// 실수 (부동소수점)
//// float double
//// 3.14
//// 1) 정규화 0.31415926535 * 10
//// 2) 31415926535 (유효숫자) 1 (지수)
//
//// float  부호(1) 지수(8) 유효숫자(23) = 32비트 = 4바이트
//// double 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8바이트
//
//float attackSpeed = -3.375f; // 4바이트
//double attackSpeed2 = 123.41223; // 8바이트
//
//// ex) -3.375라는 값을 저장
//// 1) 2진수 변환 = 3+(0.375)= 0b11 + 0b0.011 = 0b11.011
//// * 0.385 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
//// 2) 정규화 0b1.1011 * 2^1
//// 1(부호) 1(지수) 1011(유효숫자)
//// 단 지수는 unsgined byte라고 가정하고 숫자 +127 만들어줌
//// 예상 결과 : 0b 1 10000000 1011 0000 0000 0000 0000 000
//// c0 58 00 00 리틀엔디안이기때문에
//
//// 프로그래밍할 때 부동소수점은 항상 '근사값'임
//// 특히 수가 커질 수록 오차 범위도 매우 커짐
//// 실수 2개를 == 으로 비교하는 것은 지양
//
//
//
//int main()
//{
//	cout << isHighLevel << endl;
//
//
//
//}