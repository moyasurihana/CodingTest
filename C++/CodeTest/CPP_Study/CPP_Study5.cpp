//#include <iostream>
//using namespace std;
//
//// 오늘의 주제 : 데이터 연산
//// 데이터를 가공하는 방법에 대해서 알아봅시다.
//
//unsigned char flag; // 부호를 없애야  >>를 하더라도 부호비트가 딸려 오지 않음.
//
//// 한 번 정해지면 바뀌지 않을 값들
//// 다른데서 바꿀려고하면 에러가 뜸.
//
//// .rodata???
//// 사실 C++ 표준에서 꼭 그렇게 하라는 말이 없음
//// 그냥 VS 컴파일러 마음임.
//// 실제로 컴파일을해서 보면 할당이 되지 않았다고 함
//// 컴파일러가 컨스트 이름의 부분을 그냥 숫자로 바꿔치기 해버림
//const int AIR = 0;	
//const int STUN = 1;	
//const int POLYMORPH = 2;	
//
//// cons int FEAR = 3; 이런식으로 추가 가능
//const int INVINCIBLE = 3;	
//// const 는 반드시 초기화를 시켜줘야 한다.
//
//
//// * 그런데 스택영역에서 const를 선언해버리면.. 이제 스택안에 잡혀버려
//
//
//
//// 전역 변수
//// 언제 어디서든 접근 가능
//
//
//// [데이터 영역]
//// .data (초기값 있는 경우)
//int a = 2;
//
//// .bss (초기값 없는 경우)
//int b;
//
//// .rodata (읽기 전용 데이터)
//const char* msg = "Hello World";
//
//
//
//
//// main 도 함수
//int main()
//{
//
//	// [스택영역]
//	int c = 3;
//
//	
//#pragma region 비트 연산
//
//	// 언제 필요한가? (사실 많이는 없음)
//	// 비트 단위의 조작이 필요할 때
//	// - 대표적으로 BitFlag
//
//	// ~ bitwise not 
//	// 단일 숫자의 모든 비트를 대상으로, 0 은 1  , 0 은 1
//
//	// & bitwise and
//	// 두 숫자의 모든 비트 쌍을 대상으로, and 를 한다
//
//	// | bitwise or
//	// 두 숫자의 모든 비트 쌍을 대상으로, or 를 한다.
//
//	// ^ bitwise xor
//	// 두 숫자의 모든 비트 쌍을 대상으로, xor를 한다. 다르면 좋다 -> 1
//	// 두번 xor 하면은 다시 자기 숫자가 나옴
//
//
//	// << 비트 좌측 이동
//	// 비트열을 N 만큼 왼쪽으로 이동
//	// 왼쪽의 넘치는 N개의 비트는 버림, 새로 생성되는 N개의 비트는 0
//	// *2를 할 때 컴파일러가 자주보이는 패턴
//
//	// >> 비트 우측 이동
//	// 비트열을 N 만큼 우측으로 이동
//	// 오른쪽의 넘치는 N개의 비트는 버림.
//	// 왼쪽 생성되는 N개의 비트는 1이라면 1111로 계속생성되고 0이라면 0000으로 생성되어
//	// bit단위는 unsigned가 건강에 좋다.
//
//	// 불리언 노가다를 피할 수 있다.
//
//	// 실습
//	// 0b0000 [무적][변이][스턴][공중에뜸]
//	// 근데 만약 상태이상에 중간에 공포같은게 추가 되면... 고쳐주기가 매우 어려워진다.
//	// 그때 const를 쓰는거야
//
//
//	// 무적 상태로 만든다
//	// flag = ( 1 << 3 );	
//	
//	flag = (1 << INVINCIBLE);
//	
//	// 변이 상태를 추가한다(무적 +변이)
//	flag |= (1 << 2);
//
//	// 무적인지 확인하고 싶다 달느상태는 관심없음
//	// bitmask
//	bool invincible = ((flag & (1 << 3)) != 0);
//
//	// 무적이거나 스턴 상태인지 확인하고 싶다
//	// bool stunOrInvincible((flag & 0b1010) != 0);
//
//	// 또는
//	bool mask = (1 << 3) | (1 << 1);
//	bool stunOrInvincible((flag & 0b1010) != mask );
//
//
//	
//
//
//
//
//
//
//
//
//
//
//
//
//
//	
//#pragma endregion
//
//}
//
